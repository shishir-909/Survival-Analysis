count_adj <- snubber$Count[count_gt1.index] - 1
snubber.split <- snubber[rep(row.names(snubber)[count_gt1.index],count_adj),]
snubber.new <- rbind(snubber,snubber.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange(desc(Design))
sum(snubber$Count) == dim(snubber.new)[1] #check whether sum of counts equals number of rows in the new dataset
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber.new,
rho = 0
) ##rho = 0 gives log rank test
ggsurvplot(fit_snubber, data = snubber, risk.table = T, conf.int = T)
ggsurvplot(fit_snubber, pval = 0.5, risk.table = T, conf.int = T)
survminer::ggsurvplot(fit_snubber, pval = T, pval.method = T, risk.table = T, conf.int = T)
## binary vector
ten(c(1, 0, 1, 0, 1))
ten(fit_snubber)
ten_obj_snubber <- ten(fit_snubber)
View(ten_obj_snubber)
View(snubber)
comp(ten_obj_snubber)
2*(1-pnorm(0.35))
circuitPack <- read_csv("Data/CircuitPack05.csv")
circuitPack <- circuitPack %>%
dplyr::mutate(Status = case_when(`Censoring Indicator` == "Failure" ~ 1, `Censoring Indicator` == "Censored" ~ 0)) %>%
dplyr::rename(Vendor = `Vendor Number`)
knitr::kable(circuitPack, caption = "Table 2. Circuit Pack", align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
fit <- survival::survfit(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
weights = Count,
conf.type = "log",
conf.int = 0.95
)
ggsurvplot(fit, data = circuitPack, risk.table = T, ylim = c(0.95,1),  conf.int = T)
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
rho = 0
) ##rho = 0 gives log rank test
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor1")]))
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor2")]))
count_gt1.index <- which(circuitPack$Count > 1) #identify rows with count greater than 1.
count_adj <- circuitPack$Count[count_gt1.index] - 1
circuitPack.split <- circuitPack[rep(row.names(circuitPack)[count_gt1.index],count_adj),]
circuitPack.new <- rbind(circuitPack,circuitPack.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange((Vendor))
sum(circuitPack$Count) == dim(circuitPack.new)[1] #check whether sum of counts equals number of rows in the new dataset
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Vendor,
data = circuitPack.new,
rho = 0
) ##rho = 0 gives log rank test
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack.new,
rho = 0
) ##rho = 0 gives log rank test
cox_fit <- survival::coxph(survival::Surv(time = Days, event = Status) ~ Vendor, data = circuitPack, weights = Count, ties = 'efron')
summary(cox_fit)
survminer::ggsurvplot(
fit,
pval = T, #default is weight = 1 for log rank test
pval.method = T,
risk.table = T,
conf.int = T
)
ggsurvplot(fit, data = circuitPack, risk.table = T, ylim = c(0.95,1),  conf.int = T, pval = T, pval.method = T, pval.coord = c(50,0.97), pval.method.coord = c(50,0.96))
ggsurvplot(
fit,
data = circuitPack,
risk.table = T,
ylim = c(0.95, 1),
conf.int = T,
pval = 0.3,
pval.coord = c(50, 0.97),
pval.method.coord = c(50, 0.96)
)
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
rho = 0
) ##rho = 0 gives log rank test
# Chunk 1: Load Libraries
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)
library(KMsurv)
library(survival)
library(survMisc) ##Confidence bands not in survival package. survMisc is an extension of the survival package and contains confidence bands
library(tidyverse)
library(readxl)
library(readr)
library(survminer)
library(kableExtra)
setwd("I:/My Drive/rao@ualberta.ca 2022-12-08 10 58/shishir@tamu.edu/My Drive/Interesting papers/Survival Models/GitHub/Survival/Survival-Analysis/Blog 3")
# Chunk 2: Load snubber dataset
snubber <- read_csv("Data/Snubber.csv")
snubber <- snubber %>%
dplyr::mutate(Status = case_when(`Censoring Indicator` == "Failure" ~ 1, `Censoring Indicator` == "Censored" ~ 0)) %>% dplyr::rename(Cycles = `Toaster Cycles`)
knitr::kable(snubber, caption = "Table 1. Snubber", align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
# Chunk 3: snubber KM curve
fit_snubber <- survival::survfit(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber,
weights = Count,
conf.type = "log",
conf.int = 0.95
)
ggsurvplot(fit_snubber, data = snubber, risk.table = T, conf.int = T)
# Chunk 4: survdiff snubber incorrect
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber,
rho = 0
) ##rho = 0 gives log rank test
# Chunk 5: failure counts snubber
(sum(snubber$Count[which(snubber$Status ==1 & snubber$Design == "Old")]))
(sum(snubber$Count[which(snubber$Status ==1 & snubber$Design == "New")]))
# Chunk 6: snubber modify dataframe
count_gt1.index <- which(snubber$Count > 1) #identify rows with count greater than 1.
count_adj <- snubber$Count[count_gt1.index] - 1
snubber.split <- snubber[rep(row.names(snubber)[count_gt1.index],count_adj),]
snubber.new <- rbind(snubber,snubber.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange(desc(Design))
sum(snubber$Count) == dim(snubber.new)[1] #check whether sum of counts equals number of rows in the new dataset
# Chunk 7: survdiff snubber correct
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber.new,
rho = 0
) ##rho = 0 gives log rank test
#Manual calculation of log rank test for snubber dataset.
##Fit the Kaplan Meir curve to the first group.
fit_1 <- survival::survfit(
survival::Surv(
time = circuitPack$Days[which(circuitPack$Vendor == "Vendor1")]
,
event = circuitPack$Status[which(circuitPack$Vendor == "Vendor1")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = circuitPack,
weights = Count[which(circuitPack$Vendor == "Vendor1")],
conf.type = "log",
conf.int = 0.95
)
#Manual calculation of log rank test for snubber dataset.
##Fit the Kaplan Meir curve to the first group.
fit_1 <- survival::survfit(
survival::Surv(
time = snubber$Cycles[which(snubber$Design == "Old")]
,
event = snubber$Status[which(snubber$Design == "Old")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = snubber,
weights = Count[which(snubber$Design == "Old")],
conf.type = "log",
conf.int = 0.95
)
summary_fit1 <- summary(fit_1)
group1 <- data.frame(Time = summary_fit1$time,
Events = summary_fit1$n.event,
At_risk = summary_fit1$n.risk)
##Fit the Kaplan Meir curve to the second group.
fit_2 <- survival::survfit(
survival::Surv(
time = snubber$Cycles[which(snubber$Design == "New")]
,
event = snubber$Status[which(snubber$Design == "New")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = snubber,
weights = Count[which(snubber$Design == "New")],
conf.type = "log",
conf.int = 0.95
)
summary_fit2 <- summary(fit_2)
##Get the unique "event" times in the pooled sample
t.i <- sort(unique(c(summary_fit1$time, summary_fit2$time)))
##Get the number of events and number at risk at the unique event times in the pooled sample
d.i1 <- summary(fit_1, times = t.i, extend = T)$n.event
Y.i1 <- summary(fit_1, times = t.i, extend = T)$n.risk
d.i2 <- summary(fit_2, times = t.i)$n.event
Y.i2 <- summary(fit_2, times = t.i)$n.risk
master_table <- data.frame(t.i = t.i,
Y.i1 = Y.i1,
d.i1 = d.i1,
Y.i2 = Y.i2,
d.i2 = d.i2)
master_table <- master_table %>%
dplyr::mutate(Y.i = Y.i1 + Y.i2,
d.i = d.i1 + d.i2) %>%
dplyr::filter(Y.i1 != 0 & Y.i2 != 0) #We need at least one observation at risk, as per the definition of "tau" in eq 7.3.1
master_table <- master_table %>%
dplyr::mutate(expctd_events = ((Y.i1/Y.i)*(d.i)))
master_table <- master_table %>%
dplyr::mutate(difference = (d.i1 - expctd_events)) %>%
dplyr::mutate(variance = (Y.i1/Y.i)*(1-(Y.i1/Y.i))*((Y.i-d.i)/(Y.i-1))*d.i)
chi_squared.statistic <- ((sum(master_table$difference)**2))/(sum(master_table$variance))
(p_value <- 1 - pchisq(chi_squared.statistic,1))
circuitPack <- read_csv("Data/CircuitPack05.csv")
circuitPack <- circuitPack %>%
dplyr::mutate(Status = case_when(`Censoring Indicator` == "Failure" ~ 1, `Censoring Indicator` == "Censored" ~ 0)) %>%
dplyr::rename(Vendor = `Vendor Number`)
knitr::kable(circuitPack, caption = "Table 2. Circuit Pack", align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
fit <- survival::survfit(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
weights = Count,
conf.type = "log",
conf.int = 0.95
)
ggsurvplot(fit, data = circuitPack, risk.table = T, ylim = c(0.95,1),  conf.int = T)
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
rho = 0
) ##rho = 0 gives log rank test
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor1")]))
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor2")]))
count_gt1.index <- which(circuitPack$Count > 1) #identify rows with count greater than 1.
count_adj <- circuitPack$Count[count_gt1.index] - 1
circuitPack.split <- circuitPack[rep(row.names(circuitPack)[count_gt1.index],count_adj),]
circuitPack.new <- rbind(circuitPack,circuitPack.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange((Vendor))
sum(circuitPack$Count) == dim(circuitPack.new)[1] #check whether sum of counts equals number of rows in the new dataset
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack.new,
rho = 0
) ##rho = 0 gives log rank test
cox_fit <- survival::coxph(survival::Surv(time = Days, event = Status) ~ Vendor, data = circuitPack, weights = Count, ties = 'efron')
summary(cox_fit)
ggsurvplot(
fit,
data = circuitPack,
risk.table = T,
ylim = c(0.95, 1),
conf.int = T,
pval = T,
pval.method = T,
pval.coord = c(50, 0.97),
pval.method.coord = c(50, 0.96)
)
ggsurvplot(
fit,
data = circuitPack,
risk.table = T,
ylim = c(0.95, 1),
conf.int = T,
pval = 0.3,
pval.coord = c(50, 0.97),
pval.method.coord = c(50, 0.96)
)
#Manual calculation of log rank test for circuitPack dataset.
##Fit the Kaplan Meir curve to the first group.
fit_1 <- survival::survfit(
survival::Surv(
time = circuitPack$Days[which(circuitPack$Vendor == "Vendor1")]
,
event = circuitPack$Status[which(circuitPack$Vendor == "Vendor1")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = circuitPack,
weights = Count[which(circuitPack$Vendor == "Vendor1")],
conf.type = "log",
conf.int = 0.95
)
summary_fit1 <- summary(fit_1)
group1 <- data.frame(Time = summary_fit1$time,
Events = summary_fit1$n.event,
At_risk = summary_fit1$n.risk)
##Fit the Kaplan Meir curve to the second group.
fit_2 <- survival::survfit(
survival::Surv(
time = circuitPack$Days[which(circuitPack$Vendor == "Vendor2")]
,
event = circuitPack$Status[which(circuitPack$Vendor == "Vendor2")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = circuitPack,
weights = Count[which(circuitPack$Vendor == "Vendor2")],
conf.type = "log",
conf.int = 0.95
)
summary_fit2 <- summary(fit_2)
##Get the unique "event" times in the pooled sample
t.i <- sort(unique(c(summary_fit1$time, summary_fit2$time)))
##Get the number of events and number at risk at the unique event times in the pooled sample
d.i1 <- summary(fit_1, times = t.i)$n.event
Y.i1 <- summary(fit_1, times = t.i)$n.risk
d.i2 <- summary(fit_2, times = t.i)$n.event
Y.i2 <- summary(fit_2, times = t.i)$n.risk
master_table <- data.frame(t.i = t.i,
Y.i1 = Y.i1,
d.i1 = d.i1,
Y.i2 = Y.i2,
d.i2 = d.i2)
master_table <- master_table %>%
dplyr::mutate(Y.i = Y.i1 + Y.i2,
d.i = d.i1 + d.i2)
master_table <- master_table %>%
dplyr::mutate(expctd_events = ((Y.i1/Y.i)*(d.i)))
master_table <- master_table %>%
dplyr::mutate(difference = (d.i1 - expctd_events)) %>%
dplyr::mutate(variance = (Y.i1/Y.i)*(1-(Y.i1/Y.i))*((Y.i-d.i)/(Y.i-1))*d.i)
chi_squared.statistic <- ((sum(master_table$difference)**2))/(sum(master_table$variance))
p_value <- 1 - pchisq(chi_squared.statistic,1)
(p_value <- 1 - pchisq(chi_squared.statistic,1))
knitr::kable(snubber.new, caption = "Table 2. Snubber (Modified)", align = rep('c', 4), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
# Chunk 1: Load Libraries
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)
library(KMsurv)
library(survival)
library(survMisc) ##Confidence bands not in survival package. survMisc is an extension of the survival package and contains confidence bands
library(tidyverse)
library(readxl)
library(readr)
library(survminer)
library(kableExtra)
setwd("I:/My Drive/rao@ualberta.ca 2022-12-08 10 58/shishir@tamu.edu/My Drive/Interesting papers/Survival Models/GitHub/Survival/Survival-Analysis/Blog 3")
# Chunk 2: Load snubber dataset
snubber <- read_csv("Data/Snubber.csv")
snubber <- snubber %>%
dplyr::mutate(Status = case_when(`Censoring Indicator` == "Failure" ~ 1, `Censoring Indicator` == "Censored" ~ 0)) %>% dplyr::rename(Cycles = `Toaster Cycles`)
knitr::kable(snubber, caption = "Table 1. Snubber", align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
# Chunk 3: snubber KM curve
fit_snubber <- survival::survfit(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber,
weights = Count,
conf.type = "log",
conf.int = 0.95
)
ggsurvplot(
fit_snubber,
data = snubber,
risk.table = T,
conf.int = T
)
# Chunk 4: survdiff snubber incorrect
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber,
rho = 0
) ##rho = 0 gives log rank test
# Chunk 5: failure counts snubber
(sum(snubber$Count[which(snubber$Status ==1 & snubber$Design == "Old")]))
(sum(snubber$Count[which(snubber$Status ==1 & snubber$Design == "New")]))
count_gt1.index <- which(snubber$Count > 1) #identify rows with count greater than 1.
count_adj <- snubber$Count[count_gt1.index] - 1
snubber.split <- snubber[rep(row.names(snubber)[count_gt1.index],count_adj),]
snubber.new <- rbind(snubber,snubber.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange(desc(Design))
sum(snubber$Count) == dim(snubber.new)[1] #check whether sum of counts equals number of rows in the new dataset
knitr::kable(snubber.new, caption = "Table 2. Snubber (Modified)", align = rep('c', 4), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
survival::survdiff(
survival::Surv(time = Cycles, event = Status, type = 'right') ~ Design,
data = snubber.new,
rho = 0
) ##rho = 0 gives log rank test
#Manual calculation of log rank test for snubber dataset.
##Fit the Kaplan Meir curve to the first group.
fit_1 <- survival::survfit(
survival::Surv(
time = snubber$Cycles[which(snubber$Design == "Old")]
,
event = snubber$Status[which(snubber$Design == "Old")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = snubber,
weights = Count[which(snubber$Design == "Old")],
conf.type = "log",
conf.int = 0.95
)
summary_fit1 <- summary(fit_1)
group1 <- data.frame(Time = summary_fit1$time,
Events = summary_fit1$n.event,
At_risk = summary_fit1$n.risk)
##Fit the Kaplan Meir curve to the second group.
fit_2 <- survival::survfit(
survival::Surv(
time = snubber$Cycles[which(snubber$Design == "New")]
,
event = snubber$Status[which(snubber$Design == "New")]
,
type = "right"
) ~ 1 #Right hand formula for a single curve. It will use Turnbull iterative process for datasets containing left and right censored data.
,
stype = 1 #Survival type 1 means direct estimate of survival curve. Type 2 would have been exp(-H(t))
,
ctype = 1 #Cumulative Hazard type 1 is Nelson-Aalen. Type 2 is Fleming-Harrington correction for tied events.
,
data = snubber,
weights = Count[which(snubber$Design == "New")],
conf.type = "log",
conf.int = 0.95
)
summary_fit2 <- summary(fit_2)
##Get the unique "event" times in the pooled sample
t.i <- sort(unique(c(summary_fit1$time, summary_fit2$time)))
##Get the number of events and number at risk at the unique event times in the pooled sample
d.i1 <- summary(fit_1, times = t.i, extend = T)$n.event
Y.i1 <- summary(fit_1, times = t.i, extend = T)$n.risk
d.i2 <- summary(fit_2, times = t.i)$n.event
Y.i2 <- summary(fit_2, times = t.i)$n.risk
master_table <- data.frame(t.i = t.i,
Y.i1 = Y.i1,
d.i1 = d.i1,
Y.i2 = Y.i2,
d.i2 = d.i2)
master_table <- master_table %>%
dplyr::mutate(Y.i = Y.i1 + Y.i2,
d.i = d.i1 + d.i2) %>%
dplyr::filter(Y.i1 != 0 & Y.i2 != 0) #We need at least one observation at risk, as per the definition of "tau" in eq 7.3.1
master_table <- master_table %>%
dplyr::mutate(expctd_events = ((Y.i1/Y.i)*(d.i)))
master_table <- master_table %>%
dplyr::mutate(difference = (d.i1 - expctd_events)) %>%
dplyr::mutate(variance = (Y.i1/Y.i)*(1-(Y.i1/Y.i))*((Y.i-d.i)/(Y.i-1))*d.i)
chi_squared.statistic <- ((sum(master_table$difference)**2))/(sum(master_table$variance))
(p_value <- 1 - pchisq(chi_squared.statistic,1))
survminer::ggsurvplot(
fit_snubber,
pval = 0.7,
risk.table = T,
conf.int = T
)
survminer::ggsurvplot(
fit_snubber,
pval = T, #default is weight = 1 for log rank test
pval.method = T,
risk.table = T,
conf.int = T
)
circuitPack <- read_csv("Data/CircuitPack05.csv")
circuitPack <- circuitPack %>%
dplyr::mutate(Status = case_when(`Censoring Indicator` == "Failure" ~ 1, `Censoring Indicator` == "Censored" ~ 0)) %>%
dplyr::rename(Vendor = `Vendor Number`)
knitr::kable(circuitPack, caption = "Table 2. Circuit Pack", align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
fit <- survival::survfit(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
weights = Count,
conf.type = "log",
conf.int = 0.95
)
ggsurvplot(fit, data = circuitPack, risk.table = T, ylim = c(0.95,1),  conf.int = T)
survival::survdiff(
survival::Surv(time = Days, event = Status, type = 'right') ~ Vendor,
data = circuitPack,
rho = 0
) ##rho = 0 gives log rank test
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor1")]))
(sum(circuitPack$Count[which(circuitPack$Vendor == "Vendor2")]))
count_gt1.index <- which(circuitPack$Count > 1) #identify rows with count greater than 1.
count_adj <- circuitPack$Count[count_gt1.index] - 1
circuitPack.split <- circuitPack[rep(row.names(circuitPack)[count_gt1.index],count_adj),]
circuitPack.new <- rbind(circuitPack,circuitPack.split) %>% dplyr::select(!c("Count")) %>% dplyr::arrange((Vendor))
sum(circuitPack$Count) == dim(circuitPack.new)[1] #check whether sum of counts equals number of rows in the new dataset
knitr::kable(circuitPack.new, caption = "Table 3. Circuit Pack (Modified)", align = rep('c', 4), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
