View(fitModel1.KaplanMeir)
fitModel1.KaplanMeir[["time"]]
fitModel1.KaplanMeir[["n.event"]]
View(confBands2)
confBands2[["surv"]]
#Next, we will plot a Weibull plot of the standardized residuals. In order to plot a Weibull plot, I need to plot log(t.p) vs log[-log(1-p)] as per Section 6.2.4 in SMRD2. Note that (1-p) is nothing but the Kaplan Meir survival probability (because p is the CDF).
#First, I need the Kaplan Meir estimate of the CDF of the standardized residuals
fitModel1.KaplanMeir <- survival::survfit(Surv(stdResid.round,delta) ~ 1, data = ceramic)
summary(fitModel1.KaplanMeir)
#Next, I need the confidence band. I tried using the survMisc package, but the confidence bands I was getting did not make sense. The survival lower and upper bounds of the survival probability band increased at some times, which does not make sense because survival function is strictly non-increasing. The survMisc package is from 2016 and is very old. I used the km.ci package with the log transformed Equal probability band and even this gave me confidence bands where the survival function increased at some point. After reading the section on confidence bands in SMRD2 (Section 3.8 in Chapter 3), I realized that it is possible that sometimes this can happen. Don't panic! All you need to do is adjust the confidence bands as mentioned in the Section 3.8. Here is what you need to do to adjust the bands: "If the upper band is decreasing on the left, it is made flat from tL(a) to the point of the minimum. If the lower band is decreasing on the right, it is made flat from the point of maximum to tU(b) . These adjustments, if needed, give tighter, more sensible bands and have no effect on the actual coverage probability of the nonparametric simultaneous bands." This is also mentioned in SAS documentation here: "https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.4/statug/statug_lifetest_details11.htm", but it references the same SMRD2 book.
#Also, the latest version of the km.ci package is from 2022 and is newer as compared to survMisc. Going forward, I should use km.ci for confidence bands and not survMisc.
#survFitObject <- survival::survfit(Surv(stdResid.round,delta) ~ 1, data = ceramic) #Required for km.ci on the next line.
confBands2 <- km.ci::km.ci(fitModel1.KaplanMeir, conf.level = 0.95, method = "logep") #"logep" recommended by km.ci package documentation.
#create a dataframe with all the probabilities that I need to plot
weibullPlot.model1 <- data.frame(t.p = fitModel1.KaplanMeir[["time"]],
survival.p = fitModel1.KaplanMeir[["surv"]]) %>%
dplyr::mutate(p = 1 - survival.p) %>%
dplyr::filter(row_number() <= n()-1) %>% #The observation with survival probability 0 i.e. the last observation is removed since we cannot have confidence band values for this observation.
dplyr::mutate(survival.lower = confBands2$lower,
survival.upper = confBands2$upper) %>%
dplyr::mutate(p.lower = round(1 - survival.upper,3),
p.upper = round(1 - survival.lower,3))
xTransformer <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
#Plot Fig 17.5 b
ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.05))
#Notice that the upper bound of the confidence band decreases at a point. Hence, an adjustment, as discussed above, is needed.
weibullPlot.model1$p.upper[c(1)] <- weibullPlot.model1$p.upper[2]
#Plot 17.5b again, with the adjusted upper band.
1-pchisq(333,1)
1-pchisq(20,3)
# Chunk 1: Load Libraries
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)
library(survival)
library(tidyverse)
library(readr)
library(survminer)
library(kableExtra)
library(flexsurv)
library(gridExtra)
library(km.ci)
setwd("G:/My Drive/rao@ualberta.ca 2022-12-08 10 58/shishir@tamu.edu/My Drive/Interesting papers/Survival Models/GitHub/Survival/Survival-Analysis/Blog 5")
# Chunk 2: Load Table
ceramic <- read_csv("Data/CeramicBearing02.csv", show_col_types = FALSE)
knitr::kable(ceramic, align = rep('c', 5), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
#, caption = "Table 1. Ceramic Bearings Life Test Data"
# Chunk 3: Rename Columns
ceramic <- ceramic %>%
dplyr::rename(Revolutions = `Millions of Revolutions`,
Stress = `Stress (Mpsi)`) %>%
dplyr::mutate(delta = rep(1,nrow(ceramic))) #No censored observations
# Chunk 5: Linear axes
ggplot(ceramic, aes(x = Stress, y = Revolutions)) + geom_point() + ylab("Millions of Revolutions") + xlab("Stress (Mpsi)") + ggtitle("Linear axes")
# Chunk 6: Log-log axes
ggplot(ceramic, aes(x = Stress, y = Revolutions)) + geom_point() + ylab("Millions of Revolutions") + xlab("Stress (Mpsi)") + coord_trans(x = 'log', y = 'log') + ggtitle("Log-Log axes")
# Chunk 7: CDF & ML fits SepDists
#Fig 17.7 a and b equivalent for ceramic data
##I need the Kaplan Meir estimates of the CDF for each level of stress. Instead of coding 4 separate times for 4 stress levels, I am going to loop it.
uniqueStress <- sort(unique(ceramic$Stress))
Fig17_CDF <- list() #Non parametric CDF estimates for all plots in Fig 17
Fig17.a_MLest <- list() #Maximum likelihood estimates of plot (a) i.e lognormal
Fig17.b_MLest <- list() #Maximum likelihood estimates of plot (b) i.e weibull
i <- 1
while(i <= length(uniqueStress)){
df <- ceramic %>%
dplyr::filter(Stress == uniqueStress[i])
fit_df <- survival::survfit(Surv(Revolutions, delta) ~ 1, data = df)
temp_df <- data.frame(Revolutions = fit_df$time,
p = 1-fit_df$surv)
temp_df <- temp_df %>%
dplyr::mutate(bottomOfStairs = c(0,head(p,-1))) %>%
dplyr::mutate(middleOfStairs = (p + bottomOfStairs)/2) %>% #Note: p is top of stairs.
dplyr::select(!p) %>%
dplyr::rename(p = middleOfStairs) #This piece of code is for plotting the CDF at the mid point of the jumps instead of plotting at the top of the jumps. See Section 6.4.2 of Chapter 6 in SMRD2.
Fig17_CDF[[i]] <- temp_df
para_fit_logNormal <- survival::survreg(Surv(Revolutions, delta) ~ 1, data = df, dist = "lognormal")
Fig17.a_MLest[[i]] <- c(
para_fit_logNormal[["coefficients"]], #mu
para_fit_logNormal[["scale"]], #sigma
para_fit_logNormal[["loglik"]][2], #log likelihood
sqrt(para_fit_logNormal[["var"]][1, 1]), #s.e of mu
(para_fit_logNormal[["scale"]] * sqrt(para_fit_logNormal[["var"]][2, 2])) #s.e of scale
)
para_fit_weibull <- survival::survreg(Surv(Revolutions, delta) ~ 1, data = df, dist = "weibull")
Fig17.b_MLest[[i]] <- c(
para_fit_weibull[["coefficients"]], #mu
para_fit_weibull[["scale"]], #sigma
para_fit_weibull[["loglik"]][2], #log-likelihood
sqrt(para_fit_weibull[["var"]][1, 1]), #s.e of mu
(para_fit_weibull[["scale"]] * sqrt(para_fit_weibull[["var"]][2, 2])) #s.e of sigma
)
i = i + 1
}
names(Fig17_CDF) <- uniqueStress
names(Fig17.a_MLest) <- uniqueStress
names(Fig17.b_MLest) <- uniqueStress
#In order to linearize a log-normal distribution, log(t.p) vs phi inverse(p) plots as a straight line. See Section 6.2.3 in SMRD2. We will now code the 2 transformers for X and Y axes for log-normal
xTransformer.logNormal <- scales::trans_new(
name = "logNormal.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.logNormal <- scales::trans_new(
name = "logNormal.y.transform",
transform = function(p){
y = qnorm(p)
return(y)
},
inverse = function(y) {
p = pnorm(y)
return(p)
}
)
#In order to linearize a weibull distribution, log(t.p) vs log[-log(1-p)] plots as a straight line. See Section 6.2.4 in SMRD2. We will now code the 2 transformers for X and Y axes for weibull
xTransformer.weibull <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.weibull <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
# Chunk 8: Log-normal
#Log normal plot 17.7 a
cols <- c("0.87 Mpsi"="red","0.99 Mpsi"="blue","1.09 Mpsi"="green","1.18 Mpsi"="orange")
ggplot() + geom_point(
data = Fig17_CDF[["0.87"]],
aes(x = Revolutions, y = p, color = "0.87 Mpsi")
) + geom_point(
data = Fig17_CDF[["0.99"]],
aes(x = Revolutions, y = p, color = "0.99 Mpsi"),
) + geom_point(
data = Fig17_CDF[["1.09"]],
aes(x = Revolutions, y = p, color = "1.09 Mpsi")
) + geom_point(
data = Fig17_CDF[["1.18"]],
aes(x = Revolutions, y = p, color = "1.18 Mpsi")
) + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Revolutions",
breaks = c(10, 100, 1000, 10000, 100000)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.00,1.0,0.05)
) + geom_abline(
aes(intercept = (-Fig17.a_MLest[["0.87"]][1]/Fig17.a_MLest[["0.87"]][2]), #y-axis intercept
slope = 1/Fig17.a_MLest[["0.87"]][2], color = "0.87 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.a_MLest[["0.99"]][1]/Fig17.a_MLest[["0.99"]][2]), #y-axis intercept
slope = 1/Fig17.a_MLest[["0.99"]][2], color = "0.99 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.a_MLest[["1.09"]][1]/Fig17.a_MLest[["1.09"]][2]), #y-axis intercept
slope = 1/Fig17.a_MLest[["1.09"]][2], color = "1.09 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.a_MLest[["1.18"]][1]/Fig17.a_MLest[["1.18"]][2]), #y-axis intercept
slope = 1/Fig17.a_MLest[["1.18"]][2], color = "1.18 Mpsi")
) + ggtitle(label = "Log-Normal") + scale_color_manual(name="Stress",values = cols)
# Chunk 9: Weibull plot
#Weibull plot 17.7 b
cols <- c("0.87 Mpsi"="red","0.99 Mpsi"="blue","1.09 Mpsi"="green","1.18 Mpsi"="orange")
ggplot() + geom_point(
data = Fig17_CDF[["0.87"]],
aes(x = Revolutions, y = p, color = "0.87 Mpsi")
) + geom_point(
data = Fig17_CDF[["0.99"]],
aes(x = Revolutions, y = p, color = "0.99 Mpsi"),
) + geom_point(
data = Fig17_CDF[["1.09"]],
aes(x = Revolutions, y = p, color = "1.09 Mpsi")
) + geom_point(
data = Fig17_CDF[["1.18"]],
aes(x = Revolutions, y = p, color = "1.18 Mpsi")
) + scale_x_continuous(
transform = xTransformer.weibull,
name = "Millions of Revolutions",
breaks = c(10, 100, 1000, 10000, 100000)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.00,1.00,0.05)
) + geom_abline(
aes(intercept = (-Fig17.b_MLest[["0.87"]][1]/Fig17.b_MLest[["0.87"]][2]), #y-axis intercept
slope = 1/Fig17.b_MLest[["0.87"]][2], color = "0.87 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.b_MLest[["0.99"]][1]/Fig17.b_MLest[["0.99"]][2]), #y-axis intercept
slope = 1/Fig17.b_MLest[["0.99"]][2], color = "0.99 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.b_MLest[["1.09"]][1]/Fig17.b_MLest[["1.09"]][2]), #y-axis intercept
slope = 1/Fig17.b_MLest[["1.09"]][2], color = "1.09 Mpsi")
) + geom_abline(
aes(intercept = (-Fig17.b_MLest[["1.18"]][1]/Fig17.b_MLest[["1.18"]][2]), #y-axis intercept
slope = 1/Fig17.b_MLest[["1.18"]][2], color = "1.18 Mpsi")
) + ggtitle(label = "Weibull") + scale_color_manual(name="Stress",values = cols)
# Chunk 10: Prep ML table 2
Fig4.paras <- data.frame(
mu = c(
Fig17.b_MLest[["0.87"]][1],
Fig17.b_MLest[["0.99"]][1],
Fig17.b_MLest[["1.09"]][1],
Fig17.b_MLest[["1.18"]][1]
),
se.mu = c(
Fig17.b_MLest[["0.87"]][4],
Fig17.b_MLest[["0.99"]][4],
Fig17.b_MLest[["1.09"]][4],
Fig17.b_MLest[["1.18"]][4]
),
sigma = c(
Fig17.b_MLest[["0.87"]][2],
Fig17.b_MLest[["0.99"]][2],
Fig17.b_MLest[["1.09"]][2],
Fig17.b_MLest[["1.18"]][2]
),
se.sigma = c(
Fig17.b_MLest[["0.87"]][5],
Fig17.b_MLest[["0.99"]][5],
Fig17.b_MLest[["1.09"]][5],
Fig17.b_MLest[["1.18"]][5]
)
)
#knitr::kable(Fig4.paras, "latex")
rownames(Fig4.paras) <- c("0.87 Mpsi", "0.99 Mpsi", "1.09 Mpsi", "1.18 Mpsi")
colnames(Fig4.paras) <- c("$\\hat{\\mu}$","$\\mathrm SE_{\\hat{\\mu}}$","$\\hat{\\sigma}$","$\\mathrm SE_{\\hat{\\sigma}}$")
SepDists_LL <- round(Fig17.b_MLest[["0.87"]][3] + Fig17.b_MLest[["0.99"]][3] + Fig17.b_MLest[["1.09"]][3] + Fig17.b_MLest[["1.18"]][3],3)
# Chunk 11: ML Table 2
knitr::kable(Fig4.paras, align = rep('c', 5), table.envir = 'table*', escape = FALSE, digits = 3) %>%
kableExtra::kable_styling("striped", full_width = T, position = "left")
#, caption = "Table 2. Maximum Likelihood estimates"
# Chunk 12: EqualSig Model
para_fit_weibull.Factor <- survival::survreg(Surv(Revolutions, delta) ~ factor(Stress, levels = uniqueStress), data = ceramic, dist = "weibull")
summary(para_fit_weibull.Factor)
mu.0.87.Fig17.10c <- para_fit_weibull.Factor[["coefficients"]][1] #baseline/intercept
se.mu.0.87.Fig17.10c <- sqrt(para_fit_weibull.Factor[["var"]][1,1])
mu.0.99.Fig17.10c <- mu.0.87.Fig17.10c + para_fit_weibull.Factor[["coefficients"]][2] #Because mu.270.Fig17.7c is the intercept i.e baseline
se.mu.0.99.Fig17.10c <- sqrt(para_fit_weibull.Factor[["var"]][1,1] + para_fit_weibull.Factor[["var"]][2,2] + (2*para_fit_weibull.Factor[["var"]][1,2])) #Var(beta.0 + beta.1) = Var(beta.0) + Var(beta.1) + 2*Covar(beta.0. beta.1)
mu.1.09.Fig17.10c <- mu.0.87.Fig17.10c + para_fit_weibull.Factor[["coefficients"]][3] #Because mu.270.Fig17.7c is the intercept i.e baseline
se.mu.1.09.Fig17.10c <- sqrt(para_fit_weibull.Factor[["var"]][1,1] + para_fit_weibull.Factor[["var"]][3,3] + (2*para_fit_weibull.Factor[["var"]][1,3])) #Var(beta.0 + beta.1) = Var(beta.0) + Var(beta.1) + 2*Covar(beta.0. beta.1)
mu.1.18.Fig17.10c <- mu.0.87.Fig17.10c + para_fit_weibull.Factor[["coefficients"]][4] #Because mu.270.Fig17.7c is the intercept i.e baseline
se.mu.1.18.Fig17.10c <- sqrt(para_fit_weibull.Factor[["var"]][1,1] + para_fit_weibull.Factor[["var"]][4,4] + (2*para_fit_weibull.Factor[["var"]][1,4])) #Var(beta.0 + beta.1) = Var(beta.0) + Var(beta.1) + 2*Covar(beta.0. beta.1)
sigma.Fig17.10c <- para_fit_weibull.Factor[["scale"]]
se.sigma.Fig17.10c <- sqrt(para_fit_weibull.Factor[["var"]][4,4] * (para_fit_weibull.Factor[["scale"]]**2))
# Chunk 13: Weibull plot EqualSig
#Weibull plot 17.10 c
cols <- c("0.87 Mpsi"="red","0.99 Mpsi"="blue","1.09 Mpsi"="green","1.18 Mpsi"="orange")
ggplot() + geom_point(
data = Fig17_CDF[["0.87"]],
aes(x = Revolutions, y = p, color = "0.87 Mpsi")
) + geom_point(
data = Fig17_CDF[["0.99"]],
aes(x = Revolutions, y = p, color = "0.99 Mpsi"),
) + geom_point(
data = Fig17_CDF[["1.09"]],
aes(x = Revolutions, y = p, color = "1.09 Mpsi")
) + geom_point(
data = Fig17_CDF[["1.18"]],
aes(x = Revolutions, y = p, color = "1.18 Mpsi")
) + scale_x_continuous(
transform = xTransformer.weibull,
name = "Hours",
breaks = c(10,50,100,250,500, 1000,1100)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.00,0.99,0.05)
) + geom_abline(
aes(intercept = (-mu.0.87.Fig17.10c/sigma.Fig17.10c), #y-axis intercept
slope = 1/sigma.Fig17.10c, color = "0.87 Mpsi")
) + geom_abline(
aes(intercept = (-mu.0.99.Fig17.10c/sigma.Fig17.10c), #y-axis intercept
slope = 1/sigma.Fig17.10c, color = "0.99 Mpsi")
) + geom_abline(
aes(intercept = (-mu.1.09.Fig17.10c/sigma.Fig17.10c), #y-axis intercept
slope = 1/sigma.Fig17.10c, color = "1.09 Mpsi")
) + geom_abline(
aes(intercept = (-mu.1.18.Fig17.10c/sigma.Fig17.10c), #y-axis intercept
slope = 1/sigma.Fig17.10c, color = "1.18 Mpsi")
) + ggtitle(label = "Weibull EqualSig") + scale_color_manual(name="Stress",values = cols)
# Chunk 14: Prep ML table 3
Fig5.paras <- data.frame(
mu = c(
mu.0.87.Fig17.10c,
mu.0.99.Fig17.10c,
mu.1.09.Fig17.10c,
mu.1.18.Fig17.10c
),
se.mu = c(
se.mu.0.87.Fig17.10c,
se.mu.0.99.Fig17.10c,
se.mu.1.09.Fig17.10c,
se.mu.1.18.Fig17.10c
),
sigma = rep(sigma.Fig17.10c,4),
se.sigma = rep(se.sigma.Fig17.10c,4)
)
#knitr::kable(Fig4.paras, "latex")
rownames(Fig5.paras) <- c("0.87 Mpsi", "0.99 Mpsi", "1.09 Mpsi", "1.18 Mpsi")
colnames(Fig5.paras) <- c("$\\hat{\\mu}$","$\\mathrm SE_{\\hat{\\mu}}$","$\\hat{\\sigma}$","$\\mathrm SE_{\\hat{\\sigma}}$")
EqualSig_LL <- round(para_fit_weibull.Factor[["loglik"]][2],3)
# Chunk 15: ML Table 3
knitr::kable(Fig5.paras, align = rep('c', 5), table.envir = 'table*', escape = FALSE, digits = 3) %>%
kableExtra::kable_styling("striped", full_width = T, position = "left")
#, caption = "Table 2. Maximum Likelihood estimates"
# Chunk 16: Regression model
para_fit_weibull.Fig17.10d <- survival::survreg(Surv(Revolutions, delta) ~ log(Stress), data = ceramic, dist = "weibull")
summary(para_fit_weibull.Fig17.10d)
(-2)*para_fit_weibull.Fig17.10d$loglik[2]
beta.0 <- para_fit_weibull.Fig17.10d[["coefficients"]][1]
se.beta.0 <- sqrt(para_fit_weibull.Fig17.10d[["var"]][1,1])
beta.1 <- para_fit_weibull.Fig17.10d[["coefficients"]][2]
se.beta.1 <- sqrt(para_fit_weibull.Fig17.10d[["var"]][2,2])
sigma.Fig17.10d <- para_fit_weibull.Fig17.10d[["scale"]]
se.sigma.Fig17.10d <- sqrt(para_fit_weibull.Fig17.10d[["var"]][3,3] * (para_fit_weibull.Fig17.10d[["scale"]]**2))
RegrParas <- data.frame(
ML_est = c(beta.0, beta.1, sigma.Fig17.10d),
Std.Err = c(se.beta.0, se.beta.1, se.sigma.Fig17.10d),
Wald_0.95_Lower = c(
beta.0 - (qnorm(0.975) * se.beta.0),
beta.1 - (qnorm(0.975) * se.beta.1),
exp(log(para_fit_weibull.Fig17.10d[["scale"]]) - (
qnorm(0.975) * sqrt(para_fit_weibull.Fig17.10d[["var"]][3, 3])
))
),
Wald_0.95_Upper = c(
beta.0 + (qnorm(0.975) * se.beta.0),
beta.1 + (qnorm(0.975) * se.beta.1),
exp(log(para_fit_weibull.Fig17.10d[["scale"]]) + (
qnorm(0.975) * sqrt(para_fit_weibull.Fig17.10d[["var"]][3, 3])
))
)
)
rownames(RegrParas) <- c("$\\hat{\\beta_{0}}$", "$\\hat{\\beta_{1}}$", "$\\hat{\\sigma}$")
colnames(RegrParas) <- c("ML estimate","Standard Error","Wald Lower 95% CI","Wald Upper 95% CI")
Regr_LL <- round(para_fit_weibull.Fig17.10d[["loglik"]][2],3)
# Chunk 17: ML Table 4
knitr::kable(RegrParas, align = rep('c', 5), table.envir = 'table*', escape = FALSE, digits = 3) %>%
kableExtra::kable_styling("striped", full_width = T, position = "left")
#, caption = "Table 2. Maximum Likelihood estimates"
# Chunk 18: Weibull plot regression parameters
mu.0.87.Fig17.10d <- log(predict(para_fit_weibull.Fig17.10d,
newdata = data.frame(Stress = 0.87)))
mu.0.99.Fig17.10d <- log(predict(para_fit_weibull.Fig17.10d,
newdata = data.frame(Stress = 0.99)))
mu.1.09.Fig17.10d <- log(predict(para_fit_weibull.Fig17.10d,
newdata = data.frame(Stress = 1.09)))
mu.1.18.Fig17.10d <- log(predict(para_fit_weibull.Fig17.10d,
newdata = data.frame(Stress = 1.18)))
sigma.Fig17.10d <- para_fit_weibull.Fig17.10d[["scale"]]
# Chunk 19: Weibull plot Regression
#Weibull plot 17.10 d
cols <- c("0.87 Mpsi"="red","0.99 Mpsi"="blue","1.09 Mpsi"="green","1.18 Mpsi"="orange")
ggplot() + geom_point(
data = Fig17_CDF[["0.87"]],
aes(x = Revolutions, y = p, color = "0.87 Mpsi")
) + geom_point(
data = Fig17_CDF[["0.99"]],
aes(x = Revolutions, y = p, color = "0.99 Mpsi"),
) + geom_point(
data = Fig17_CDF[["1.09"]],
aes(x = Revolutions, y = p, color = "1.09 Mpsi")
) + geom_point(
data = Fig17_CDF[["1.18"]],
aes(x = Revolutions, y = p, color = "1.18 Mpsi")
) + scale_x_continuous(
transform = xTransformer.weibull,
name = "Hours",
breaks = c(10,50,100,250,500, 1000,1100)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.00,0.99,0.05)
) + geom_abline(
aes(intercept = (-mu.0.87.Fig17.10d/sigma.Fig17.10d), #y-axis intercept
slope = 1/sigma.Fig17.10d, color = "0.87 Mpsi")
) + geom_abline(
aes(intercept = (-mu.0.99.Fig17.10d/sigma.Fig17.10d), #y-axis intercept
slope = 1/sigma.Fig17.10d, color = "0.99 Mpsi")
) + geom_abline(
aes(intercept = (-mu.1.09.Fig17.10d/sigma.Fig17.10d), #y-axis intercept
slope = 1/sigma.Fig17.10d, color = "1.09 Mpsi")
) + geom_abline(
aes(intercept = (-mu.1.18.Fig17.10d/sigma.Fig17.10d), #y-axis intercept
slope = 1/sigma.Fig17.10d, color = "1.18 Mpsi")
) + ggtitle(label = "Weibull Regression") + scale_color_manual(name="Stress",values = cols)
# Chunk 20: Quantiles Calculation
quantiles_0.1_0.5 <- predict(para_fit_weibull.Fig17.10d,
newdata = data.frame(Stress = 1.15), type = 'quantile', p=c(0.1,0.5), se.fit = T)
lower_wald95 <- exp(log(quantiles_0.1_0.5$fit) - (qnorm(0.975)*quantiles_0.1_0.5$se.fit/quantiles_0.1_0.5$fit))
upper_wald95 <- exp(log(quantiles_0.1_0.5$fit) + (qnorm(0.975)*quantiles_0.1_0.5$se.fit/quantiles_0.1_0.5$fit))
quantile_df <- data.frame(t.p = quantiles_0.1_0.5$fit, t.p.se = quantiles_0.1_0.5$se.fit, wald_lower = lower_wald95,
wald_upper = upper_wald95)
rownames(quantile_df) <- c("$\\hat{t_{0.1}}$","$\\hat{t_{0.5}}$")
colnames(quantile_df) <- c("ML estimate","Standard Error","Wald Lower 95% CI","Wald Upper 95% CI")
# Chunk 21: ML Table 5
knitr::kable(quantile_df, align = rep('c', 5), table.envir = 'table*', escape = FALSE, digits = 3) %>%
kableExtra::kable_styling("striped", full_width = T, position = "left")
#, caption = "Table 2. Maximum Likelihood estimates"
# Chunk 22: Std. Residuals vs Fitted Values
#First, add a column for the linear predictors. This is nothing but "mu + gamma.transpose*Z" for every observation.
ceramic <- ceramic %>%
dplyr::mutate(LinearPredictor = para_fit_weibull.Fig17.10d[["linear.predictors"]])
#Next, add a column for standardized residuals. The definition of standardized residual for a log-location-scale model is given by Eq 17.12 in SMRD2
ceramic <- ceramic %>%
dplyr::mutate(stdResid = exp((log(Revolutions)-LinearPredictor)/para_fit_weibull.Fig17.10d[["scale"]])) %>%
dplyr::mutate(stdResid.round = round(stdResid,3))
# Chunk 23: Std Resid vs fitted
ggplot(ceramic, aes(x = exp(LinearPredictor), y = stdResid, group = delta)) + geom_point() + coord_trans(x = 'log', y = 'log') + ylab("Standardized Residuals") + xlab("Fitted Values") #Matches figure 17.5a! Notice that the variability is higher at larger fitted values.
#+ geom_point(aes(shape = factor(delta, levels = c(1,0))))
# Chunk 24: Std. Residuals Weibull Plot Calculation
#Next, we will plot a Weibull plot of the standardized residuals. In order to plot a Weibull plot, I need to plot log(t.p) vs log[-log(1-p)] as per Section 6.2.4 in SMRD2. Note that (1-p) is nothing but the Kaplan Meir survival probability (because p is the CDF).
#First, I need the Kaplan Meir estimate of the CDF of the standardized residuals
fitModel1.KaplanMeir <- survival::survfit(Surv(stdResid.round,delta) ~ 1, data = ceramic)
summary(fitModel1.KaplanMeir)
#Next, I need the confidence band. I tried using the survMisc package, but the confidence bands I was getting did not make sense. The survival lower and upper bounds of the survival probability band increased at some times, which does not make sense because survival function is strictly non-increasing. The survMisc package is from 2016 and is very old. I used the km.ci package with the log transformed Equal probability band and even this gave me confidence bands where the survival function increased at some point. After reading the section on confidence bands in SMRD2 (Section 3.8 in Chapter 3), I realized that it is possible that sometimes this can happen. Don't panic! All you need to do is adjust the confidence bands as mentioned in the Section 3.8. Here is what you need to do to adjust the bands: "If the upper band is decreasing on the left, it is made flat from tL(a) to the point of the minimum. If the lower band is decreasing on the right, it is made flat from the point of maximum to tU(b) . These adjustments, if needed, give tighter, more sensible bands and have no effect on the actual coverage probability of the nonparametric simultaneous bands." This is also mentioned in SAS documentation here: "https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.4/statug/statug_lifetest_details11.htm", but it references the same SMRD2 book.
#Also, the latest version of the km.ci package is from 2022 and is newer as compared to survMisc. Going forward, I should use km.ci for confidence bands and not survMisc.
#survFitObject <- survival::survfit(Surv(stdResid.round,delta) ~ 1, data = ceramic) #Required for km.ci on the next line.
confBands2 <- km.ci::km.ci(fitModel1.KaplanMeir, conf.level = 0.95, method = "logep") #"logep" recommended by km.ci package documentation.
#create a dataframe with all the probabilities that I need to plot
weibullPlot.model1 <- data.frame(t.p = fitModel1.KaplanMeir[["time"]],
survival.p = fitModel1.KaplanMeir[["surv"]]) %>%
dplyr::mutate(p = 1 - survival.p) %>%
dplyr::filter(row_number() <= n()-1) %>% #The observation with survival probability 0 i.e. the last observation is removed since we cannot have confidence band values for this observation.
dplyr::mutate(survival.lower = confBands2$lower,
survival.upper = confBands2$upper) %>%
dplyr::mutate(p.lower = round(1 - survival.upper,3),
p.upper = round(1 - survival.lower,3))
xTransformer <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
#Plot Fig 17.5 b
ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.05))
#Notice that the upper bound of the confidence band decreases at a point. Hence, an adjustment, as discussed above, is needed.
weibullPlot.model1$p.upper[c(1)] <- weibullPlot.model1$p.upper[2]
#Plot 17.5b again, with the adjusted upper band.
# Chunk 25: Std Resid Weibull plot
ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1,2,3)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.1))
# Chunk 26
report::cite_packages()
# Chunk 29: bib
# create a bib file for the R packages used in this document
knitr::write_bib(c('base', 'rmarkdown'), file = 'skeleton.bib')
ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1,2,3)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.1))
std.resid.prob.plot <- ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1,2,3)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.1))
std.resid.prob.plot <- ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1,2,3)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.1))
R <- suppressWarnings(print(std.resid.prob.plot))
R
std.resid.prob.plot <- ggplot(weibullPlot.model1, aes(x = t.p, y = p)) + geom_point() + geom_step(aes(y = p.lower)) + geom_step(aes(y = p.upper)) + scale_x_continuous(transform = xTransformer, name = "Standardized Residuals", breaks = c(0.001,0.01, 0.1, 1,2,3)) + scale_y_continuous(transform = yTransfomer, name = "Fraction Failing",breaks = seq(0.01,0.99,0.1))
R <- suppressWarnings(print(std.resid.prob.plot))
