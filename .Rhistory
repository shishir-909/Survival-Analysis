#The next 2 lines of code gives the coverage probability for the upper and lower bounds. See section 3.3 in the paper linked here: https://drive.google.com/open?id=1yqxRGOqa1-FVEou9B8jw89xQSjmYPiij&usp=drive_fs
(CP.PI.FRW.upper <- ((1/B)*sum(pnorm((log(T.tilda.upper.B)-mu.ML)/sigma.ML))))
(CP.PI.FRW.lower <- ((1/B)*sum(1-pnorm((log(T.tilda.lower.B)-mu.ML)/sigma.ML))))
T.tilda.lower.calib.FRW <- exp(mu.ML + (qnorm(1-0.96)*sigma.ML))
T.tilda.upper.calib.FRW <- exp(mu.ML + (qnorm(0.96)*sigma.ML))
(T.tilda.lower.calib.FRW <- exp(mu.ML + (qnorm(1-0.96)*sigma.ML)))
(T.tilda.upper.calib.FRW <- exp(mu.ML + (qnorm(0.96)*sigma.ML)))
fit_3 <- survival::survfit(Surv(Operations, delta) ~ 1, data = MechanicalSwitch)
summary(fit_3)
CDF_df <- data.frame(Operations = fit_3$time,
p = 1 - fit_3$surv) %>%
dplyr::distinct(p, .keep_all = TRUE) #This line is required. Otherwise, the time column includes all observations. I just need the observations where there is a jump in the CDF.
CDF_df <- CDF_df %>%
dplyr::mutate(bottomOfStairs = c(0,head(p,-1))) %>%
dplyr::mutate(middleOfStairs = (p + bottomOfStairs)/2) %>% #Note: p is top of stairs.
dplyr::select(!p) %>%
dplyr::rename(p = middleOfStairs) #This piece of code is for plotting the CDF at the mid point of the jumps instead of plotting at the top of the jumps. See Section 6.4.2 of Chapter 6 in SMRD2.
fit.weibull <- survival::survreg(Surv(Operations, delta) ~ 1, data = MechanicalSwitch, dist = "weibull")
summary(fit.weibull)
mu.ML_Weibull <- fit.weibull$coefficients
sigma.ML_Weibull <- fit.weibull$scale
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_Weibull)/sigma.ML_Weibull
dgdMu <- (-1/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_Weibull <- sqrt(((dgdMu**2)*(se_mu.ML_Weibull**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_Weibull*fit_1[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_Weibull**2)))
mu.ML_Weibull <- fit.weibull$coefficients
se_mu.ML_Weibull <- sqrt(fit.weibull[["var"]][1,1])
sigma.ML_Weibull <- fit.weibull$scale
se_sigma.ML_Weibull <- sqrt((sigma.ML_Weibull**2)*fit.weibull[["var"]][2,2])
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_Weibull)/sigma.ML_Weibull
dgdMu <- (-1/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_Weibull <- sqrt(((dgdMu**2)*(se_mu.ML_Weibull**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_Weibull*fit_1[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_Weibull**2)))
se_Ft.ML_Weibull <- sqrt(((dgdMu**2)*(se_mu.ML_Weibull**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_Weibull*fit.weibull[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_Weibull**2)))
se_e_Weibull <- (1/sigma.ML_Weibull)*sqrt((se_mu.ML_Weibull**2) + (2*e*(sigma.ML_Weibull*fit.weibull[["var"]][1,2])) + ((e**2)*(se_sigma.ML_Weibull**2)))
CI_lower_e_Weibull <- e - (qnorm(0.975)*se_e_Weibull)
CI_upper_e_Weibull <- e + (qnorm(0.975)*se_e_Weibull)
CI_lower_eFt_Weibull <- 1 - exp(-exp(CI_lower_e_Weibull))
CI_upper_eFt_Weibull <- 1 - exp(-exp(CI_upper_e_Weibull))
CDF_CI_Weibull_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_Weibull,
CI_Upper = CI_upper_eFt_Weibull)
xTransformer.weibull <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.weibull <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_Weibull_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_Weibull_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.weibull$coefficients/fit.weibull$scale), #y-axis intercept
slope = 1/fit.weibull$scale)
)  + scale_x_continuous(
transform = xTransformer.weibull,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_Weibull_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_Weibull_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.weibull$coefficients/fit.weibull$scale), #y-axis intercept
slope = 1/fit.weibull$scale)
)  + scale_x_continuous(
transform = xTransformer.weibull,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "Weibull Probability Plot")
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
dgdMu <- (-1/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- 1 - exp(-exp(CI_lower_e_logNormal))
CI_upper_eFt_logNormal <- 1 - exp(-exp(CI_upper_e_logNormal))
CDF_CI_logNormal_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
#Points (We already have this from the Weibull plot)
#Line. Note that lognormal ML fit already available from fit.logNormal
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
#Dashed lines. Prepare a dataframe to hold values of the CI for F(t). We will use the CI based on "e", as done in chunk 4
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
dgdMu <- (-1/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
#Confidence interval based on "e".
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- 1 - exp(-exp(CI_lower_e_logNormal))
CI_upper_eFt_logNormal <- 1 - exp(-exp(CI_upper_e_logNormal))
CDF_CI_logNormal_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
#Transformers
xTransformer.weibull <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.weibull <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_logNormal_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_logNormal_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.logNormal$coefficients/fit.logNormal$scale), #y-axis intercept
slope = 1/fit.logNormal$scale)
)  + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "logNormal Probability Plot")
#Points (We already have this from the Weibull plot)
#Line. Note that lognormal ML fit already available from fit.logNormal
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
#Dashed lines. Prepare a dataframe to hold values of the CI for F(t). We will use the CI based on "e", as done in chunk 4
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
dgdMu <- (-1/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_logNormal)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
#Confidence interval based on "e".
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- 1 - exp(-exp(CI_lower_e_logNormal))
CI_upper_eFt_logNormal <- 1 - exp(-exp(CI_upper_e_logNormal))
CDF_CI_logNormal_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
#Transformers
xTransformer.logNormal <- scales::trans_new(
name = "logNormal.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.logNormal <- scales::trans_new(
name = "logNormal.y.transform",
transform = function(p){
y = qnorm(p)
return(y)
},
inverse = function(y) {
p = pnorm(y)
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_logNormal_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_logNormal_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.logNormal$coefficients/fit.logNormal$scale), #y-axis intercept
slope = 1/fit.logNormal$scale)
)  + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "logNormal Probability Plot")
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_Lognormal)/sigma.ML_Lognormal
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
Ft.ML_Lognormal <- pnorm(e)
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
Ft.ML_Lognormal <- pnorm(e)
dgdMu <- (-1/sigma.ML_logNormal)*dnorm(e)
dgdSigma <- (-e/sigma.ML_logNormal)*dnorm(e)
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit_2[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
Ft.ML_Lognormal <- pnorm(e)
dgdMu <- (-1/sigma.ML_logNormal)*dnorm(e)
dgdSigma <- (-e/sigma.ML_logNormal)*dnorm(e)
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- pnorm(CI_lower_e_logNormal)
CI_upper_eFt_logNormal <- pnorm(CI_upper_e_logNormal)
CDF_CI_logNormal_df <- data.frame(Kilometers = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
xTransformer.logNormal <- scales::trans_new(
name = "logNormal.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.logNormal <- scales::trans_new(
name = "logNormal.y.transform",
transform = function(p){
y = qnorm(p)
return(y)
},
inverse = function(y) {
p = pnorm(y)
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_logNormal_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_logNormal_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.logNormal$coefficients/fit.logNormal$scale), #y-axis intercept
slope = 1/fit.logNormal$scale)
)  + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "logNormal Probability Plot")
#Points (We already have this from the Weibull plot)
#Line. Note that lognormal ML fit already available from fit.logNormal
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
#Dashed lines. Prepare a dataframe to hold values of the CI for F(t). We will use the CI based on "e", as done in chunk 5
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
Ft.ML_Lognormal <- pnorm(e)
#To get standard error of the above CDF, use equation 8.8 from SMRD2. My proof for 8.8 is here: https://drive.google.com/open?id=12D9tcASJAgxY2kecw2tbCGUK9a8RfrQK&usp=drive_fs
dgdMu <- (-1/sigma.ML_logNormal)*dnorm(e)
dgdSigma <- (-e/sigma.ML_logNormal)*dnorm(e)
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
#Confidence interval based on "e".
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- pnorm(CI_lower_e_logNormal)
CI_upper_eFt_logNormal <- pnorm(CI_upper_e_logNormal)
CDF_CI_logNormal_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
#Transformers
xTransformer.logNormal <- scales::trans_new(
name = "logNormal.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.logNormal <- scales::trans_new(
name = "logNormal.y.transform",
transform = function(p){
y = qnorm(p)
return(y)
},
inverse = function(y) {
p = pnorm(y)
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_logNormal_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_logNormal_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.logNormal$coefficients/fit.logNormal$scale), #y-axis intercept
slope = 1/fit.logNormal$scale)
)  + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "logNormal Probability Plot")
#Points
fit_3 <- survival::survfit(Surv(Operations, delta) ~ 1, data = MechanicalSwitch)
summary(fit_3)
CDF_df <- data.frame(Operations = fit_3$time,
p = 1 - fit_3$surv) %>%
dplyr::distinct(p, .keep_all = TRUE) #This line is required. Otherwise, the time column includes all observations. I just need the observations where there is a jump in the CDF.
CDF_df <- CDF_df %>%
dplyr::mutate(bottomOfStairs = c(0,head(p,-1))) %>%
dplyr::mutate(middleOfStairs = (p + bottomOfStairs)/2) %>% #Note: p is top of stairs.
dplyr::select(!p) %>%
dplyr::rename(p = middleOfStairs) #This piece of code is for plotting the CDF at the mid point of the jumps instead of plotting at the top of the jumps. See Section 6.4.2 of Chapter 6 in SMRD2.
#Line.
fit.weibull <- survival::survreg(Surv(Operations, delta) ~ 1, data = MechanicalSwitch, dist = "weibull")
summary(fit.weibull)
mu.ML_Weibull <- fit.weibull$coefficients
se_mu.ML_Weibull <- sqrt(fit.weibull[["var"]][1,1])
sigma.ML_Weibull <- fit.weibull$scale
se_sigma.ML_Weibull <- sqrt((sigma.ML_Weibull**2)*fit.weibull[["var"]][2,2])
#Dashed lines. Prepare a dataframe to hold values of the CI for F(t). We will use the CI based on "e", as done in chunk 4
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_Weibull)/sigma.ML_Weibull
dgdMu <- (-1/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
dgdSigma <- (-e/sigma.ML_Weibull)*(exp(-exp(e)))*(exp(e))
se_Ft.ML_Weibull <- sqrt(((dgdMu**2)*(se_mu.ML_Weibull**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_Weibull*fit.weibull[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_Weibull**2)))
#Confidence interval based on "e".
se_e_Weibull <- (1/sigma.ML_Weibull)*sqrt((se_mu.ML_Weibull**2) + (2*e*(sigma.ML_Weibull*fit.weibull[["var"]][1,2])) + ((e**2)*(se_sigma.ML_Weibull**2)))
CI_lower_e_Weibull <- e - (qnorm(0.975)*se_e_Weibull)
CI_upper_e_Weibull <- e + (qnorm(0.975)*se_e_Weibull)
CI_lower_eFt_Weibull <- 1 - exp(-exp(CI_lower_e_Weibull))
CI_upper_eFt_Weibull <- 1 - exp(-exp(CI_upper_e_Weibull))
CDF_CI_Weibull_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_Weibull,
CI_Upper = CI_upper_eFt_Weibull)
#Transformers
xTransformer.weibull <- scales::trans_new(
name = "weibull.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.weibull <- scales::trans_new(
name = "weibull.y.transform",
transform = function(p){
y = log(-log(1-p))
return(y)
},
inverse = function(y) {
p = 1 - exp(-exp(y))
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_Weibull_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_Weibull_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.weibull$coefficients/fit.weibull$scale), #y-axis intercept
slope = 1/fit.weibull$scale)
)  + scale_x_continuous(
transform = xTransformer.weibull,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.weibull,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "Weibull Probability Plot")
#Points (We already have this from the Weibull plot)
#Line. Note that lognormal ML fit already available from fit.logNormal
mu.ML_logNormal <- fit.logNormal$coefficients
se_mu.ML_logNormal <- sqrt(fit.logNormal[["var"]][1,1])
sigma.ML_logNormal <- fit.logNormal$scale
se_sigma.ML_logNormal <- sqrt((sigma.ML_logNormal**2)*fit.logNormal[["var"]][2,2])
#Dashed lines. Prepare a dataframe to hold values of the CI for F(t). We will use the CI based on "e", as done in chunk 5
t <-seq(1.1,3.8,length = 10000) #Range of data used
e <- (log(t) - mu.ML_logNormal)/sigma.ML_logNormal
Ft.ML_Lognormal <- pnorm(e)
#To get standard error of the above CDF, use equation 8.8 from SMRD2. My proof for 8.8 is here: https://drive.google.com/open?id=12D9tcASJAgxY2kecw2tbCGUK9a8RfrQK&usp=drive_fs
dgdMu <- (-1/sigma.ML_logNormal)*dnorm(e)
dgdSigma <- (-e/sigma.ML_logNormal)*dnorm(e)
se_Ft.ML_logNormal <- sqrt(((dgdMu**2)*(se_mu.ML_logNormal**2)) + (2*(dgdMu)*(dgdSigma)*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((dgdSigma**2)*(se_sigma.ML_logNormal**2)))
#Confidence interval based on "e".
se_e_logNormal <- (1/sigma.ML_logNormal)*sqrt((se_mu.ML_logNormal**2) + (2*e*(sigma.ML_logNormal*fit.logNormal[["var"]][1,2])) + ((e**2)*(se_sigma.ML_logNormal**2)))
CI_lower_e_logNormal <- e - (qnorm(0.975)*se_e_logNormal)
CI_upper_e_logNormal <- e + (qnorm(0.975)*se_e_logNormal)
CI_lower_eFt_logNormal <- pnorm(CI_lower_e_logNormal)
CI_upper_eFt_logNormal <- pnorm(CI_upper_e_logNormal)
CDF_CI_logNormal_df <- data.frame(Operations = t,
CI_Lower = CI_lower_eFt_logNormal,
CI_Upper = CI_upper_eFt_logNormal)
#Transformers
xTransformer.logNormal <- scales::trans_new(
name = "logNormal.x.transform",
transform = function(t.p){
x = log(t.p)
return(x)
},
inverse = function(x) {
t.p = exp(x)
return(t.p)
}
)
yTransfomer.logNormal <- scales::trans_new(
name = "logNormal.y.transform",
transform = function(p){
y = qnorm(p)
return(y)
},
inverse = function(y) {
p = pnorm(y)
return(p)
}
)
ggplot() + geom_point(data = CDF_df, aes(x = Operations, y = p)) + geom_line(data = CDF_CI_logNormal_df,
aes(x = Operations, y = CI_Lower),
linetype = "dashed") + geom_line(data= CDF_CI_logNormal_df, aes(x = Operations, y = CI_Upper), linetype = "dashed") + geom_abline(
aes(intercept = (-fit.logNormal$coefficients/fit.logNormal$scale), #y-axis intercept
slope = 1/fit.logNormal$scale)
)  + scale_x_continuous(
transform = xTransformer.logNormal,
name = "Millions of Operations",
breaks = seq(1,4, by = 0.2)
) + scale_y_continuous(
transform = yTransfomer.logNormal,
name = "Fraction Failing",
breaks = seq(0.01,0.99,0.05)
) + ggtitle(label = "logNormal Probability Plot")
AIC(fit.logNormal)
AIC(fit.weibull)
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion("tufte"), include = FALSE)
options(htmltools.dir.version = FALSE)
library(survival)
library(tidyverse)
library(readr)
MechanicalSwitch <- readr::read_csv("G:\\My Drive\\rao@ualberta.ca 2022-12-08 10 58\\shishir@tamu.edu\\My Drive\\Interesting papers\\Survival Models\\GitHub\\Survival\\Survival-Analysis\\Blog 9\\Data\\MechanicalSwitch.csv")
MechanicalSwitch <- MechanicalSwitch %>%
dplyr::mutate(delta = ifelse(MechanicalSwitch$`Failure Mode` == "Censored",0,1)) %>%
dplyr::rename(Operations = `Millions of Operations`)
View(MechanicalSwitch)
setwd("G:/My Drive/rao@ualberta.ca 2022-12-08 10 58/shishir@tamu.edu/My Drive/Interesting papers/Survival Models/GitHub/Survival/Survival-Analysis/Blog 9")
MechanicalSwitch <- readr::read_csv("Data\\MechanicalSwitch.csv", show_col_types = FALSE)
MechanicalSwitch <- readr::read_csv("Data\\MechanicalSwitch.csv", show_col_types = FALSE)
knitr::kable(MechanicalSwitch, align = rep('c', 2), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
library(knitr)
library(kableExtra)
unlink("Blog 9_cache", recursive = TRUE)
MechanicalSwitch <- readr::read_csv("Data\\MechanicalSwitch.csv", show_col_types = FALSE)
knitr::kable(MechanicalSwitch, align = rep('c', 2), table.envir = 'table*') %>%
kableExtra::kable_styling("striped", full_width = T, position = "left") %>%
kableExtra::scroll_box(height = "200px")
remove.packages(tufte)
library(tufte)
